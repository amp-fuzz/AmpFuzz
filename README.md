# AMPFUZZ: Fuzzing for Amplification DDoS Vulnerabilities (and Using Those to Synthesize DDoS Honeypots)

## Requirements
* [docker](https://www.docker.com)

## Installation
- go to the repo directory
`cd ampfuzz_repo`
- run
`docker build -t ampfuzz .`

## Usage
- copy the original (clean) evaluation directory somewhere
`cp eval/04_create_eval_dir/eval eval/04_create_eval_dir/eval~`
- got to the evaluation directory
`eval/04_create_eval_dir/eval`

### Run make
`Makefile` is generated by `gen_makefile.py` script in the same folder, you can change the timeout for every experiment and other features here then regenerate it with 
`python3 gen_makefile.py`

### Individual services
- `make openafs-fileserver/honey_syn__usr_sbin_bosserver_7007.log BUILD=1`

This command will 
1. build among (other binaries) `/usr/sbin/bosserver` from Debian package `openafs-fileserver`;
2. analyze and instrument `/usr/sbin/bosserver` to get `fast` and `track` binaries;
3. fuzz; 
4. synthesize honeypot from discovered amplifications;
5. test honeypot replaying the amplifications against it and the original service.

In the end all results populate `eval/04_create_eval_dir/eval/openafs-fileserver` directory.
All results (including intermediate one) populate docker images, each of them can be accessed via its respectful `.iid`.

Inputs triggering amplification and reflection vulnerabilities are in
`eval/04_create_eval_dir/eval/openafs-fileserver/_usr_sbin_bosserver/7007/amps`

Honeypot testing results are in 
`eval/04_create_eval_dir/eval/openafs-fileserver/honey_syn__usr_sbin_bosserver_7007/real_syn_comp.out`

### Full Evaluation on all services
- `make BUILD=1`

To streamline several fuzzing/honeypot synthesis tasks drop `BUILD=1` to use previous package builds.

## Setup without docker (not recommended)
Our setup heavily uses [docker](https://www.docker.com).
Still the toolchain could be obtained without it.

### Requirements
* wllvm (`pip install wllvm`)

### Installation
```bash
mkdir build
cd build
cmake ..
make && make install
```
## Usage
1. Compile target with `pre_clang`/`pre_clang_++`. 
    This is just a wrapper around `wllvm` to compile the target to a single llvm module
1. Create instrumented versions and `targets.json` with `make_target <target>`.
    This will extract the LLVM bitcode from the `<target>` binary and create two instrumented versions:
    1. `target.fast`: "Standard" AFL-instrumentation, shared memory hashmap that counts how often branches were taken. Linked against `runtime_fast`.
    1. `target.track`: Taint tracking instrumentation, linked against `runtime`.
    In addition, this also creates `targets.json`, which includes
    * `edges`: list of pairs of branch-IDs (basically a high-level CFG)
    * `targets`: list of branch-IDs that lead to a target. Inputs that reach more `targets` are preferred
    * `callsite_dominators`: I have not yet understood what these are for :(
1. Create folder `in/` with files for example payloads. One file per payload (e.g. `in/00`, `in/01`, etc.)
1. Run fuzzer
    ```bash
    fuzzer -c ./targets.json -i in -o out -t ./test.track --target_addr 127.0.0.1:12345 -- ./test.fast  
    ```
    where
    * `-c <path>`: which `targets.json` to load for CFG (here: `./targets.json`)
    * `-i <path>`: which folder to load inputs from (here: `in`)
    * `-o <path>`: where to write outputs to (here: `out`). **`fuzzer` will fail if directory already exists!**
    * `-t <path>`: path of taint-tracking instrumented target
    * `--target_addr addr:port`: which UDP socket the target will be listening on. Should be automated eventually (here: `127.0.0.1:12345`)
    * `-- <cmdline>`: end of arguments, what follows will be commandline to launch (fast instrumented) target (here: `./test.fast`)
   
If everything works as expected, the fuzzer should create a folder `out/amps/` that contains inputs leading to amplification.
